[{"name":"HuffmanCoding","comment":"\n\n\n# Types\n\n@docs Tree, Element, Code, Direction, HuffmanFile\n\n\n# Compression\n\n@docs compress\n\n\n# Decompression\n\n@docs decompress\n\n\n# Encoder\n\n@docs encodeCode, encodeTree, encodeFile\n\n\n# Decoder\n\n@docs decodeCode, decodeTree, decodeFile\n\n\n# Tree Helper-Functions\n\n@docs createCharCodeDictFromTree, getCharFromTreeByCode, generateTree\n\n","unions":[{"name":"Direction","comment":" Describe which tree in a Node has to chose.\n","args":[],"cases":[["Left",[]],["Right",[]]]},{"name":"Tree","comment":" A Huffman-Coding-Tree has three possible states:\n\n1.  Empty -> This tree is empty.\n2.  Node -> A Node has always two further Trees.\n3.  Leaf -> A Leaf describe one of the endpoints of a Tree.\n\nExample:\n\n    exampleTree : Tree\n    exampleTree =\n        Node (Leaf Element 'h' 1 (Leaf Element 'i' 1))\n\n","args":[],"cases":[["Empty",[]],["Node",["HuffmanCoding.Tree","HuffmanCoding.Tree"]],["Leaf",["HuffmanCoding.Element"]]]}],"aliases":[{"name":"Code","comment":" A list of Direction. It describe the route through a tree until a Leaf.\n","args":[],"type":"List.List HuffmanCoding.Direction"},{"name":"Element","comment":" An Element contains the information which char is encoded and how often this is used in the text.\n","args":[],"type":"{ char : Char.Char, numberOf : Basics.Int }"},{"name":"HuffmanFile","comment":" The HuffmanFile is a combination of the text in Codes and the Huffman-Coding-Tree which was used to create the codes.\n","args":[],"type":"{ text : List.List HuffmanCoding.Code, tree : HuffmanCoding.Tree }"}],"values":[{"name":"compress","comment":" Returns a Tuple of a Huffman-Coding-Tree and List of Codes.\nEach Code describe a Char in the String. Each Code is a route description for a Char in the Tree.\n\n    compress \"hi\"\n        == ( Node (Leaf Element 'h' 1) (Leaf Element 'i' 1)\n           , [ [ Left ], [ Right ] ]\n           )\n\n","type":"String.String -> ( HuffmanCoding.Tree, List.List HuffmanCoding.Code )"},{"name":"createCharCodeDictFromTree","comment":" Return all Chars and their Code in a Dict for a Huffman-Coding-Tree.\n\n    createCharCodeDictFromTree (Node (Node (Leaf Element 'b' 1) (Leaf Element 'l' 1)) (Node (Leaf Element 'u' 1) (Leaf Element 'e' 1)))\n        == Dict.fromList\n            [ ( 'b', [ Left, Left ] )\n            , ( 'l', [ Left, Right ] )\n            , ( 'u', [ Right, Left ] )\n            , ( 'e', [ Right, Right ] )\n            ]\n\n","type":"HuffmanCoding.Tree -> Dict.Dict Char.Char HuffmanCoding.Code"},{"name":"decodeCode","comment":" Decode two bytes into a Code.\n\n    Bytes.Decode.decode decodeCode `5C` `80`\n        == [ Right, Right, Left, Left, Right, Left ]\n\n\n    Bytes.Decode.decode decodeCode `20` `00` `24` `00` `28` `00` `2C` `00`\n        == [Left, Left] [Left, Right] [Right, Left] [Right, Right]\n\n","type":"Bytes.Decode.Decoder HuffmanCoding.Code"},{"name":"decodeFile","comment":" Decodes a sequence of bytes into a HuffmanFile.\n\n    Bytes.Decode.decode\n        decodeFile\n        | `00` `00` `00` `04` | `20` `00` - `28` `00` -  `24` `00` - `2C` `00` | `00` `00` `01` `01` `62` `00` `01` `01` `01` `6C` `00` `01` `00` `01` `01` `75` `00` `01` `01` `01` `65` `00` `01` |\n        |   Number Of Chars   |                 Codes in Bytes                 |                                                   Tree in Bytes                                                    |\n\n    == HuffmanFile\n        [ [Left, Left], [Left, Right], [Right, Left], [Right, Right] ]\n        (Node (Node (Leaf Element 'b' 1) (Leaf Element 'l' 1)) (Node (Leaf Element 'u' 1) (Leaf Element 'e' 1)))\n\n","type":"Bytes.Decode.Decoder HuffmanCoding.HuffmanFile"},{"name":"decodeTree","comment":" Decode a byte into a Node or a Leaf.\n\n    Bytes.Decode.decode decodeTree\n        |`00`| |`00`| |`00`| |`01`| |`01`| |`65`| |`00` `01`| |`01`| |`01`| |`6F`| |`00` `01`| |`01`| |`01`| |`68`| |`00` `01`| |`01`| |`01`| |`6C`| |`00` `02`|\n        == (Node ((Node (Node (Leaf Element 'e' 1) (Leaf Element 'o' 1))(Leaf Element 'h' 1)) (Leaf Element 'l' 2)))\n\n","type":"Bytes.Decode.Decoder HuffmanCoding.Tree"},{"name":"decompress","comment":" Transform a list of Codes by means of a Huffman-Coding-Tree into a String.\n\n    decompress\n        (Node (Node (Leaf Element 'n' 1) (Leaf Element 'i' 1)) (Node (Leaf Element 'c' 1) (Leaf Element 'e' 1)))\n        [ [ Left, Left ], [ Left, Right ], [ Right, Left ], [ Right, Right ] ]\n        == \"nice\"\n\n","type":"HuffmanCoding.Tree -> List.List HuffmanCoding.Code -> String.String"},{"name":"encodeCode","comment":" Create a Encoder to encode a Code. Each Code will use 2 bytes after encoding.\n\n    Bytes.Encoder.encode encodeCode [Left]\n        == Hex : `10` `00`\n        || Dual: `0001` `0000` `0000` `0000`\n\n\n    Bytes.Encoder.encode encodeCode [Left, Right, Right, Left, Left, Right, Right]\n        == Hex : `76` `60`\n        || Dual: `0111` `0110` `0110` `0000`\n\n","type":"HuffmanCoding.Code -> Bytes.Encode.Encoder"},{"name":"encodeFile","comment":" If the Tree in the HuffmanFile is able to encode correctly it returns a Just Encoder Else Nothing.\n\n    Bytes.Encode.encode encodeFile\n        HuffmanFile\n            [ [ Left, Left ], [ Left, Right ], [ Right, Left ], [ Right, Right ], [ Left, Left ], [ Left, Right ], [ Right, Left ], [ Right, Right ] ]\n            (Node (Node (Leaf Element 'b' 2) (Leaf Element 'l' 2)) (Node (Leaf Element 'u' 2) (Leaf Element 'e' 2)))\n\n            == |`00` `00` `00` `08| [ look up @encodeCode ] [ look up @encodeTree ]\n               |  Number of Codes | [    List of Codes    ] [         Tree        ]\n\n\n    Bytes.Encode.encode encodeFile\n        HuffmanFile\n            [ [ Left, Right, Left ], [Right, Right], [ Left, Left ] ]\n            (Node (Leaf Element 'a' 1) (Empty))\n\n            == Nothing\n\n","type":"HuffmanCoding.HuffmanFile -> Maybe.Maybe Bytes.Encode.Encoder"},{"name":"encodeTree","comment":" Create a Maybe-Encoder of a tree.\nIf the Tree does not include any Empty-state the result will be Just Encoder Else Nothing.\n\n    Bytes.Encode.encode encodeTree (Node Empty (Node (Leaf Element 'e' 4) (Leaf Element 'h' 4)))\n        == Nothing\n\n\n    Bytes.Encode.encode encodeTree (Node (Leaf Element '1' 1) (Leaf Element 'â‚¬' 1))\n        == Hex : |`00`| |`01`| |`01` | |`31` | |`00` `01`| |`01`| |`03` | |`E2` `82` `AC`| |`00` `01`|\n                 |Node| |Leaf| |Width| |UTF-8| |Number of| |Leaf| |Width| |     UTF-8    | |Number of|\n\n\n    Bytes.Encode.encode encodeTree (Node (Node (Leaf Element 'b' 1) (Leaf Element 'l' 1)) (Node (Leaf Element 'u' 1) (Leaf Element 'e' 1)))\n        == Hex : |`00`| |`00`| |`01`| |`01` | |`62` | |`00` `01`| |`01`| |`01` | |`6C` | |`00` `01`| |`00`| |`01`| |`01` | |`75` | |`00` `01`| |`01`| |`01` | |`6A` | |`00` `01`|\n                 |Node| |Node| |Leaf| |Width| |UTF-8| |Number of| |Leaf| |Width| |UTF-8| |Number of| |Node| |Leaf| |Width| |UTF-8| |Number of| |Leaf| |Width| |UTF-8| |Number of|\n\n","type":"HuffmanCoding.Tree -> Maybe.Maybe Bytes.Encode.Encoder"},{"name":"generateTree","comment":" Generates a Huffman-Coding-Tree for a String.\n\n    generateTree \"done\"\n        == Node\n            (Node\n                (Leaf Element 'd' 1)\n                (Leaf Element 'o' 1)\n            )\n            (Node\n                (Leaf Element 'n' 1)\n                (Leaf Element 'e' 1)\n            )\n\n","type":"String.String -> HuffmanCoding.Tree"},{"name":"getCharFromTreeByCode","comment":" Returns a Maybe Char by using the Direction in Codes.\nIt returns a `Just Char` if the route of the Directions ends in a leaf otherwise it will return `Nothing`.\n\n    getCharFromTreeByCode\n        ( Node (Node (Leaf (Element 'd' 1)) (Leaf (Element 'd' 1)) (Leaf (Element 'o' 2)) )\n        [ Right ]\n        == Just 'o'\n\n\n    getCharFromTreeByCode\n        ( Node (Node (Leaf (Element 'e' 1)) (Leaf (Element 'i' 1)) Node (Leaf (Element 'n' 1)) (Leaf (Element 's' 1)) ) )\n        [Left]\n        == Nothing\n\n\n    getCharFromTreeByCode\n        ( Node (Leaf (Element 'h' 1)) (Leaf (Element 'i' 1)) )\n        [Right, Left, Right, Right]\n        == Nothing\n\n","type":"HuffmanCoding.Tree -> HuffmanCoding.Code -> Maybe.Maybe Char.Char"}],"binops":[]}]